É recomendado fazer um downgrade do node para fazer este curso. O downgrade
do node pode ser feito usando a ferramenta nvm:
    https://github.com/nvm-sh/nvm#about

curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash

Como eu fiz: baixe o arquivo no link que está no curl acima 
e rode ele no git bash:
    https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh 

A versão do node que está em uso neste momento é a 18.12.1.
Para instalar o node 10, rode: nvm install v14.21.2
Para usar esse node, rode: nvm use v14.21.2
A versão do node selecionada pelo nvm só funciona no terminal em que
você selecionou o node.

O site do cliente do angular tem um passo a passo para instalar o cliente
recomendado pelo site do Angular.
    Site do Angular: http://angular.io
    Site do cliente do Angular: http://cli.angular.io

Para listar as versões disponíveis do Angular no npm:
    npm view @angular/cli versions

Vou tentar usar a versão 10.2.4 do cliente. A versão do curso é 10.1.6.

Após rodar o npme install -g @angular/cli, o terminal vai ter o comando ng
disponível para operar com o Angular.

O passo a passo na página do cliente Angular é:
    npm install -g @angular/cli@10.2.4
    ng new bytebank
    cd bytebank
    ng serve


Ao rodar o ng new <nome-do-projeto>, vão ser feitas algumas perguntas:
    Q: Adicionar roteamento do Angular?
    A: Não, porque vai ser feito na unha.
    Q: Qual formato de folha de estivo usar?
    A: SCSS.

Ao rodar o comando pra servir a aplicação, você pode usar o parâmetro open
para abrir a página no browser após terminar de subir o server: 
    ng serve --open


Nesse curso não será necessário o uso do Strict Mode, configuração que o 
Angular ativa em todos os projetos criados pela CLI por padrão.

Por isso, será necessário fazer algumas modificações no arquivo tsconfig.json
para ter os resultados encontrados pelo instrutor nos vídeos.

Padrão de nomenclatura dos componentes no Angular:
    src/app/<nome-do-componente>
        -> <nome-do-componente>.component.ts
        -> <nome-do-componente>.component.scss
        -> <nome-do-componente>.component.html

O arquivo .ts conterá a lógica do componente, e usa a seguinte estrutura:
    import { Component } from '@angular/core';

    @Component({
        selector: 'componente', // Nome da tag para chamar o componente.
        templateUrl: './componente.component.html',
        styleUrls: ['./componente.component.scss']
    })
    export class ComponenteComponent {
        title = 'bytebank';
        // ... propriedades do componente.
    }

Instale o Angular Extension Pack no VS Code.

Dentro do arquivo angular.json há o objeto projects/<projeto atual>/prefix.
Todos os componentes dentro de <projeto atual> devem usar no seletor o prefix.

Além de definir o prefixo do seletor do componente, precisamos declará-lo no 
módulo (arquivo app.module.ts).

Sobre o SCSS:
    É possível aninhar estilos. Para isso, use o & (e comercial) mais o sufixo
    desejado para o estilo aninhado.

    Podemos declarar variáveis no SCSS, prefixando o nome da variável com --
    (dois hifens).

    Para usar a variável declarada, usamos:
        propriedadeCSS: var(--nomeDaVariavel);
        Ex.: .seletor { color: var(--primary); }

Para inserir um evento no formulário, precisamos de usar o Forms Module 
do Angular. Para isso, precisamos importá-lo no arquivo app.module.ts.

Perceba que declarar um componente do desenvolvedor é diferente de importar
um módulo do Angular. 
    1) Nas declarations, declaramos os componentes do desenvolvedor;
    2) Nos imports, importamos os módulos do Angular que queremos usar.

No Angular, inserimos parênteses na tag do componente para assosciar eventos 
ao componente. Isso é chamado event binding.

Exemplo de event binding:
    <form class="formulario" (evento)="metodoDaClasse()">
        ...
    </form>

O evento ngSubmit é mais poderoso do que o evento submit.

Quando referenciamos uma propriedade da classe do componente (conforme .ts),
ela é acessível pelo HTML do componente por meio de property binding:
    1) use a diretiva ngModel: <tag ([ngModel])="propriedade" ... >;
    2) defina o nome do objeto: 
          <tag ([ngModel])="propriedade" name="nome"> 
       ou use a diretiva ngModelOptions: 
          <tag ([ngModel])="propriedade" [ngModelOptions]="{standalone: true}">

Ao atribuir valores iniciais ao componente, eles já aparecem no componente.

Quando usamos declaramos a property binding, ele pode ser:
    1) One-way data binding: [ngModel]="propriedade"; ou
    2) Two-way data binding: ([ngModel])="propriedade".

Two-way binding permite que o HTML modifique o modelo no .ts e vice-versa.
One-way binding só permite mudanças do componente pro template (só no js).

O decorator Output serve para marcar um campo de classe como propriedade de 
saída. EventEmitter é uma interface, cujo método emit é usado para disparar o 
evento (EventEmitter representa um evento personalizado).

Quando o componente-filho (no exemplo, nova-transferencia) emite um evento, 
ele pode ser capturado pelo componente pai (no exemplo, app).

Quando submetemos o formulário:
    1)  O componente nova-transferencia invoca o seu método 
        NovaTransferenciaComponent.transferir(), que dispara aoTransferir;
    2)  O componente app captura o evento aoTransferir (EventEmitter) e o 
        trata no método AppComponent.transferir($event), que recebe como 
        parâmetro o evento que ele capturou.

Analisando do componente filho para o pai:
    NovaTransferenciaComponent (no arquivo .ts) declara:
        1)  o método decorado com @Output, cujo nome vai ser usado no event
            binding no componente pai (app);
        2)  o método a partir do qual será disparado o evento que vai ser 
            propagado para o componente pai (app).
    
    O template do AppComponent (app.component.html) declara:
        1)  o componente filho (nova-transferencia)
        2)  o event binding com o evento declarado no componente filho;
        3)  o método que será invocado do AppComponent (no .ts).

Encadeamento opcional: The ?. operator is like the . chaining operator, 
except that instead of causing an error if a reference is nullish (null or 
undefined), the expression short-circuits with a return value of undefined. 
When used with function calls, it returns undefined if the given function 
does not exist.

Traduzindo: colocando interrogação antes do ponto pode antecipar o retorno
de undefined, caso o objeto seja nulo.
